#cmakedefine SERVER_MAIN
#ifdef SERVER_MAIN
#include "control_server.h"
#else
#include "control.h"
#endif

TimestampStringBuf::TimestampStringBuf(void) :
                    timestamped(false),
                    output(&std::cout) {}
TimestampStringBuf::TimestampStringBuf(std::ostream& stream, bool timestamped = false) :
                    timestamped(timestamped),
                    output(&stream) {}
TimestampStringBuf::~TimestampStringBuf(void) {
    // Destructor cannot call virtual methods, ensure final flush always occurs
    if (pbase() != pptr()) putOutput();
}
int TimestampStringBuf::sync(void) {
    putOutput();
    return 0;
}
void TimestampStringBuf::putOutput() {
    // Output the timestamp
    if (timestamped) {
        std::chrono::time_point<std::chrono::system_clock> currentTimePoint =
                std::chrono::system_clock::now();
        std::chrono::duration<long int, std::ratio<1,1'000'000'000> > ns =
                std::chrono::duration_cast<std::chrono::nanoseconds>(currentTimePoint.time_since_epoch()) % 1'000'000'000;
        std::time_t current_time =
                std::chrono::system_clock::to_time_t(currentTimePoint);
        std::tm* localTime = std::localtime(&current_time);
        (*output) << std::put_time(localTime, "[%F %T.")
                  << std::setfill('0') << std::setw(9) << ns.count() << "] ";
    }
    // Output the buffer and reset it
    (*output) << str();
    str("");
    // Flush the output stream
    output->flush();
}
std::ostream* TimestampStringBuf::getOutput() const {
    return output;
}
void TimestampStringBuf::changeStream(std::ostream& changedStream) {
    output = &changedStream;
}

Output::Output(void) : std::ostream(&buffer),
                       buffer(std::cout, false),
                       defaultToCout(true),
                       detectedAsSudo(detectSudo()) {}
Output::Output(std::ostream& stream, bool timestamped = false) :
                       std::ostream(&buffer),
                       buffer(stream, timestamped),
                       defaultToCout(true),
                       detectedAsSudo(detectSudo()) {}
Output::Output(bool isCout, bool timestamped = false) :
                       std::ostream(&buffer),
                       buffer((isCout) ? std::cout : std::cerr, timestamped),
                       defaultToCout(isCout),
                       detectedAsSudo(detectSudo()) {}
Output::~Output(void) {
    // While current implementation has I/O access separated by processes,
    // it could become multithreaded at some point. Even though I expect
    // destructors and file selection to remain single-thread operations,
    // better to be a bit cautious now at negligible performance cost
    // than to forget this later and suffer
    std::lock_guard<std::mutex> lock(fileMutex);
    closeFile();
}
bool Output::detectSudo(void) {
    const char* sudo_uid_str = getenv("SUDO_UID"),
              * sudo_gid_str = getenv("SUDO_GID");
    if (sudo_uid_str && sudo_gid_str) {
        sudo_uid = static_cast<uid_t>(std::stoi(sudo_uid_str));
        sudo_gid = static_cast<gid_t>(std::stoi(sudo_gid_str));
        return true;
    }
    return false;
}
// Operator overload here is ONLY to permit RHS operation, leave LHS alone
std::ostream& operator<<(std::ostream& os, Output& obj) {
    os << "Output[";
    if (obj.fname[0]) os << obj.fname << (obj.detectedAsSudo ? "; access mode: SUDO" : "; access mode: USER");
    else if (obj.is_cout()) os << "std::cout";
    else if (obj.is_cerr()) os << "std::cerr";
    else throw std::runtime_error("Lost track of filename, not std::cout or std::cerr");
    os << "]";
    return os;
}
void Output::closeFile(void) {
    if (fileStream.is_open() && is_custom()) fileStream.close();
    std::memset(fname, 0, NAME_BUFFER_SIZE);
}
bool Output::openFile(const char * openName) {
    std::lock_guard<std::mutex> lock(fileMutex);
    closeFile();
    fileStream.open(openName, std::ios::out | std::ios::app);
    if (fileStream.is_open()) {
        if (detectedAsSudo && (chown(openName, sudo_uid, sudo_gid) == -1))
            std::cerr << "Failed to change ownership of file '" << openName <<"', will be owned by root" << std::endl;
        std::strncpy(fname, openName, NAME_BUFFER_SIZE);
        return true;
    }
    else {
        std::cerr << "Failed to open file '" << openName << "'" << std::endl;
        return false;
    }
}
bool Output::is_cout() { return buffer.getOutput() == &std::cout; }
bool Output::is_cerr() { return buffer.getOutput() == &std::cerr; }
bool Output::is_custom() { return (buffer.getOutput() != &std::cout) && (buffer.getOutput() != &std::cerr); }
void Output::revert(void) {
    closeFile();
    if (defaultToCout) buffer.changeStream(std::cout);
    else buffer.changeStream(std::cerr);
}
void Output::redirect(const char * openName) {
    if (openFile(openName)) buffer.changeStream(fileStream);
    else {
        std::cerr << "Failed to redirect to file '" << openName << "'" << std::endl;
        revert();
    }
}
void Output::redirect(std::filesystem::path fpath) { redirect(fpath.string().c_str()); }


/*
   Read command line and parse arguments
   Pointer args used to store semantic settings for program execution
 */
void parse(int argc, char** argv) {
    char* PROGNAME = argv[0];
    int c, bad_args = 0;

    // Getopt option declarations
    static struct option long_options[] = {
        {"help", no_argument, 0, 'h'},
        #ifndef SERVER_MAIN
            #ifdef BUILD_CPU
            {"cpu", no_argument, 0, 'c'},
            #endif
            #ifdef BUILD_GPU
            {"gpu", no_argument, 0, 'g'},
            #endif
            #ifdef BUILD_POD
            {"submer", no_argument, 0, 's'},
            #endif
            #ifdef BUILD_NVME
            {"nvme", no_argument, 0, 'n'},
            #endif
            {"ipaddr", required_argument, 0, 'I'},
            {"connections", required_argument, 0, 'C'},
        #else
            {"clients", required_argument, 0, 'C'},
        #endif
        {"format", required_argument, 0, 'f'},
        {"log", required_argument, 0, 'l'},
        {"errorlog", required_argument, 0, 'L'},
        {"poll", required_argument, 0, 'p'},
        {"initial-wait", required_argument, 0, 'i'},
        {"post-wait", required_argument, 0, 'w'},
        {"timeout", required_argument, 0, 't'},
        {"debug", required_argument, 0, 'd'},
        {"version", no_argument, 0, 'v'},
        {0,0,0,0}
    };
    const char* optionstr = "h"
    #ifndef SERVER_MAIN
        #ifdef BUILD_CPU
        "c"
        #endif
        #ifdef BUILD_GPU
        "g"
        #endif
        #ifdef BUILD_POD
        "s"
        #endif
        #ifdef BUILD_NVME
        "n"
        #endif
        "I:"
    #endif
    "C:f:l:L:p:i:w:t:d:v";
    // Disable getopt's automatic error message -- we'll catch it via the '?' return and shut down
    opterr = 0;

    // Parsing loop
    while (1) {
        int option_index = 0;
        c = getopt_long(argc, argv, optionstr, long_options, &option_index);
        if (c == -1) break;
        switch (c) {
            // This case may be deprecated -- blindly following a demo that includes it for some reason
            case 0:
                std::cerr << "Weird option " << long_options[option_index].name;
                if (optarg) std::cerr << " with arg " << optarg;
                std::cerr << std::endl;
                break;
            case 'h':
                std::cout << "SensorTools v" << SensorToolsVersion << std::endl;
                std::cout << "Usage: " << PROGNAME << " [options]" << std::endl;
                std::cout << "\t-h | --help\n\t\t" <<
                             "Print this help message and exit" << std::endl;
                #ifndef SERVER_MAIN
                    #ifdef BUILD_CPU
                    std::cout << "\t-c | --cpu\n\t\t" <<
                                 "Query CPU stats only (default: CPU and GPU)" << std::endl;
                    #endif
                    #ifdef BUILD_GPU
                    std::cout << "\t-g | --gpu\n\t\t" <<
                                 "Query GPU stats only (default: GPU and CPU)" << std::endl;
                    #endif
                    #ifdef BUILD_POD
                    std::cout << "\t-s | --submer\n\t\t" <<
                                 "Query Submer Pod stats (default: Not queried)" << std::endl;
                    #endif
                    #ifdef BUILD_NVME
                    std::cout << "\t-n | --nvme\n\t\t" <<
                                 "Query NVMe device temperatures (default: Not queried)" << std::endl;
                    #endif
                    std::cout << "\t-I | --ipaddr\n\t\t" <<
                                 "IP address of a server to coordinate with (server controls start/stop of measurements and any applications)" << std::endl;
                    std::cout << "\t-C [value] | --connections [value]\n\t\t" <<
                                 "Maximum number of attempts to connect to server (default: " << args.connection_attempts << "), use negative value for infinite" << std::endl;
                #else
                    std::cout << "\t-C | --clients\n\t\t" <<
                                 "Number of clients to connect to server" << std::endl;
                #endif
                std::cout << "\t-f [level] | --format [level]\n\t\t" <<
                             "Output format [0 = CSV == default | 1 = human-readable | 2 = JSON]" << std::endl;
                std::cout << "\t-l [file] | --log [file]\n\t\t" <<
                             "File to write output to" << std::endl;
                std::cout << "\t-L [file] | --errorlog [file]\n\t\t" <<
                             "File to write extra debug/errors to" << std::endl;
                std::cout << "\t-p [interval] | --poll [interval]\n\t\t" <<
                             "Floating point interval in seconds to poll stats (interval > 0)" << std::endl;
                std::cout << "\t-i [interval] | --initial-wait [interval]\n\t\t" <<
                             "Floating point interval in seconds to wait between collection initalization and starting subcommands (interval > 0)" << std::endl;
                std::cout << "\t-w [interval] | --post-wait [interval]\n\t\t" <<
                             "Floating point interval in seconds to wait after subcommand completion\n\t\t" <<
                             "A negative interval indicates to wait up to that many seconds or when temperatures return to initial levels" << std::endl;
                std::cout << "\t-t [interval] | --timeout [interval]\n\t\t" <<
                             "Floating point interval in seconds for servers and clients to cease connection attempts\n\t\t" <<
                #ifdef SERVER_MAIN
                             "Servers default to infinte waiting period until all clients arrive"
                #else
                             "Clients default to attempting to locate the server up to " << args.connection_attempts << " times (regardless of walltime duration)"
                #endif
                             << std::endl;
                std::cout << "\t-d [level] | --debug [level]\n\t\t" <<
                             "Debug verbosity (default: " << DebugOFF << ", maximum: " << DebugVerbose << ")" << std::endl;
                std::cout << "\t-v | --version\n\t\t" <<
                             "Ouput version of SensorTools and dependent libraries" << std::endl;
                std::cout << std::endl << "To automatically wrap another command with sensing for its duration, specify that command after the '--' argument" <<
                             std::endl << "ie: " << PROGNAME << " -- sleep 3" << std::endl;
                exit(EXIT_SUCCESS);
            #ifndef SERVER_MAIN
                #ifdef BUILD_CPU
                case 'c':
                    args.cpu = true;
                    break;
                #endif
                #ifdef BUILD_GPU
                case 'g':
                    args.gpu = true;
                    break;
                #endif
                #ifdef BUILD_POD
                case 's':
                    args.submer = true;
                    break;
                #endif
                #ifdef BUILD_NVME
                case 'n':
                    args.nvme = true;
                    break;
                #endif
                case 'I':
                    args.ip_addr = argv[optind-1];
                    break;
                case 'C':
                    args.connection_attempts = atoi(optarg);
                    break;
            #else
                case 'C':
                    args.clients = atoi(optarg);
                    break;
            #endif
            case 'f':
                args.format = atoi(optarg);
                // Validate the argument choice
                if (args.format < 0 || args.format >= count_OutputFormats) {
                    std::cerr << "Invalid setting for " << argv[optind-2] << ": " << optarg <<
                    "\n\tFormats are specified by integers [0-" << count_OutputFormats << ")" << std::endl;
                    bad_args += 1;
                }
                break;
            case 'l':
                args.log_path = std::filesystem::path(optarg);
                args.log.redirect(args.log_path);
                break;
            case 'L':
                args.error_log_path = std::filesystem::path(optarg);
                args.error_log.redirect(args.error_log_path);
                break;
            case 'p':
                args.poll = atof(optarg);
                if (args.poll <= 0) {
                    std::cerr << "Invalid setting for " << argv[optind-2] << ": " << optarg <<
                                 "\n\tPolling duration must be greater than 0" << std::endl;
                    bad_args += 1;
                }
                else args.poll_duration = static_cast<std::chrono::duration<double>>(args.poll); // Set sleep time for nanosleep
                break;
            case 'i':
                args.initial_wait = atof(optarg);
                if (args.initial_wait <= 0) {
                    std::cerr << "Invalid setting for " << argv[optind-2] << ": " << optarg <<
                                "\n\tInitial wait duration must be greater than 0" << std::endl;
                    bad_args += 1;
                }
                else args.initial_duration = static_cast<std::chrono::duration<double>>(args.initial_wait);
                break;
            case 'w':
                args.post_wait = atof(optarg);
                // Post wait can be less than zero to indicate a negative timeout
                args.post_duration = static_cast<std::chrono::duration<double>>(args.post_wait);
                break;
            case 't':
                args.timeout = atof(optarg);
                break;
            case 'd':
                args.debug = atoi(optarg);
                if (args.debug < 0 || args.debug >= count_DebugLevels) { // Invalid debug levels
                    std::cerr << "Invalid setting for " << argv[optind-2] << ": " << optarg <<
                                 "\n\tDebug levels are specified by integers [0-" << count_DebugLevels << ")" << std::endl;
                    bad_args += 1;
                }
                break;
            case 'v':
                args.version = true;
                break;
            case '?':
                std::cerr << "Unrecognized argument: " << argv[optind-1] << std::endl;
                bad_args += 1;
                break;
        }
    }
    // Post-reading logic
    if (!args.any_active()) args.default_active(); // Ensure defaults always on
    if (optind < argc) {
        args.wrapped = const_cast<char**>(&argv[optind]);
        if (args.debug >= DebugMinimal && args.error_log.is_cerr()) {
            std::cerr << "Treating additional arguments as a command to wrap:" << std::endl;
            for (int i = 0; i < argc-optind; i++) std::cerr << args.wrapped[i] << " ";
            std::cerr << std::endl;
        }
        if (args.poll == 0) {
            std::cerr << "Polling duration must be > 0 when wrapping a command" << std::endl;
            bad_args += 1;
        }
    }
    else args.wrapped = nullptr;
    #ifndef SERVER_MAIN
    if (args.wrapped != nullptr && args.ip_addr != nullptr) {
        std::cerr << "IP address for server given, but also a wrapped command!" << std::endl <<
                     "Server should run the wrapped command for proper synchronization" << std::endl;
        bad_args += 1;
    }
    #else
    if (args.wrapped == nullptr && args.poll != 0)
        std::cerr << "Warning! No wrapped command but polling indefinitely. You may wish to omit your polling argument for a demo or provide a wrapped command after the -- separator" << std::endl;
    #endif

    if (bad_args > 0) exit(EXIT_FAILURE);
}




// Definition of external variables for IO tools
arguments args;
// Flag that permits update logging upon collection (prevents first row from being logged prior to CSV headers)
bool update = false;

