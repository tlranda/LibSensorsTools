/*
    May be pulled in multiple times in multi-file linking
    only define once
*/
#ifndef SensorIOtools
#define SensorIOtools
// Headers and why they're included
// Document necessary compiler flags beside each header as needed in full-line comment below the header
#include <iostream> // std file descriptors
#include <sstream> // stringbuf
#include <iomanip> // setw, setfill manipulators
#include <ctime> // localtime(), tm* data
#include <unistd.h> // needed for basic getopt functionality
#include <getopt.h> // provides getopt-long() definition
#include <filesystem> // Manage I/O for writing to files rather than standard file descriptors
// May require: -lstdc++fs
#include <fstream> // for ofstream classes/types
#include <mutex> // Currently single-threaded, but permit thread safety for IO
#include <string> // String class and manipulation
#include <cstring> // strncopy(), memset()
#include <nlohmann/json.hpp> // JSON parsing
// Requires submodule pull to fetch dependency

// LibSensors and NVML demos typically allocate this much space for chip/driver names
#define NAME_BUFFER_SIZE 200
#define SensorToolsVersion "0.2.0"
#define SensorToolsPort 8080
#cmakedefine BUILD_CPU
#cmakedefine BUILD_GPU
#cmakedefine BUILD_POD
#cmakedefine BUILD_NVME
#cmakedefine SERVER_MAIN
// End Headers



// Class and Type declarations
// Debug levels as enum to automatically count the range of argument values
enum DebugLevels {
DebugOFF,
DebugMinimal,
DebugVerbose,
count_DebugLevels
};

// Output formats that can be selected
enum OutputFormats {
OutputCSV,
OutputHuman,
OutputJSON,
count_OutputFormats
};

// Buffering for injecting timestamps with flush
// Implemented based on SO answer: https://stackoverflow.com/a/2212940/13189459
class TimestampStringBuf : public std::stringbuf {
    private:
        std::ostream* output;
        bool timestamped;
    public:
        TimestampStringBuf(void);
        TimestampStringBuf(std::ostream& stream, bool timestamped);
        ~TimestampStringBuf(void);
        virtual int sync(void);
        void putOutput(void);
        std::ostream* getOutput(void) const;
        void changeStream(std::ostream& changedStream);
};


// Class permits output to std::cout by default but can be flexibly redirected as needed
// Based on code generated by ChatGPT because I'm too dumb to fix C++ I/O myself
class Output : public std::ostream {
private:
    TimestampStringBuf buffer;
    bool defaultToCout, detectedAsSudo;
    uid_t sudo_uid;
    gid_t sudo_gid;
    std::mutex fileMutex;
    std::ofstream fileStream;
    char fname[NAME_BUFFER_SIZE];

    bool detectSudo(void);
    bool openFile(const char* openName);
    void closeFile(void);
public:
    Output(void);
    Output(std::ostream& str, bool timestamped);
    Output(bool direction, bool timestamped);
    ~Output(void);
    // Permit outputting this object to streams for debug and control how output functions
    // Right-side overload
    friend std::ostream& operator<<(std::ostream& os, Output& obj);
    // Quick checks for convenience
    bool is_cout();
    bool is_cerr();
    bool is_custom();
    // Safely close any existing file (except std::cout/std::cerr) and redirect this reference to a given filename
    // Falls back to std descriptor if the file cannot be opened
    void redirect(const char* fname);
    void redirect(std::filesystem::path fpath);
    // Safely close any existing file (except std::cout/std::cerr) and return output to std descriptor
    void revert();
};


// Argument values stored here
typedef struct argstruct {
    bool help = 0,
         #ifndef SERVER_MAIN
             #ifdef BUILD_CPU
             cpu = 0,
             #endif
             #ifdef BUILD_GPU
             gpu = 0,
             #endif
             #ifdef BUILD_POD
             submer = 0,
             #endif
             #ifdef BUILD_NVME
             nvme = 0,
             #endif
         #endif
         version = 0,
         shutdown = 0;
    #ifdef SERVER_MAIN
    int clients = 0;
    #endif
    short format = 0, debug = 0;
    std::filesystem::path log_path, error_log_path;
    Output log, error_log = Output(false, true);
    double poll = 0., initial_wait = 0., post_wait = 0.;
    std::chrono::duration<double> poll_duration, initial_duration, post_duration;
    char **wrapped, *ip_addr = nullptr;
    bool any_active(void) {
        bool ret = 0;
        #ifndef SERVER_MAIN
            #ifdef BUILD_CPU
            ret = ret | cpu;
            #endif
            #ifdef BUILD_GPU
            ret = ret | gpu;
            #endif
            #ifdef BUILD_POD
            ret = ret | submer;
            #endif
            #ifdef BUILD_NVME
            ret = ret | nvme;
            #endif
        #endif
        return ret;
    }
    void default_active(void) {
        #ifndef SERVER_MAIN
            #ifdef BUILD_CPU
            cpu = 1;
            #endif
            #ifdef BUILD_GPU
            gpu = 1;
            #endif
            // Other tools only default when not built with CPU and not built with GPU
            #ifndef BUILD_CPU
            #ifndef BUILD_GPU
                #ifdef BUILD_POD
                submer = 1;
                #endif
                #ifdef BUILD_NVME
                nvme = 1;
                #endif
            #endif
            #endif
        #endif
    }
} arguments;
// End Class and Type declarations



// Function declarations
void parse(int argc, char** argv);
// End Function declarations



// External variable declarations
extern arguments args;
extern bool update;
// End External variable declarations
#endif

